import torch
import osqp
import numpy as np
from scipy import sparse
import traceback,sys

QP_REQUESTS = 0

def solveQP(H,f,A,b,LB,UB,QPsolver,torch_device, double_precision):
    """
    solveQP:
        Convenience wrapper for any quadprog interface QP solver.  This
        wrapper function will suppress any warnings from the underlying
        quadprog solver and catch any errors that are thrown and rethrow
        them as specific error types, such that they can be caught and
        dealt with accordingly.

        solveQP also keeps tracks of the number of times:
        - solveQP has called quadprog
        - quadprog has thrown an error or returned an invalid result;
            a result is considered invalid if it is exactly zero, contains
            infs/NaNs, or is empty.
        
        To access this metadata:
        [requests,errors] = solveQP('counts');
        
        To reset these counters:
        clear solveQP;
        
        INPUT:  
        same arguments as quadprog plus an additional field to
        quadprog's options struct: 
        
        .suppress_warnings                  [logical | {true}]
            suppress all warnings and error messages generated by 
            quadprog (except for license issues)
        
        OUTPUT: 
        X and LAMBDA output arguments from full call to quadprog:
        [X,FVAL,EXITFLAG,OUTPUT,LAMBDA] = quadprog(...)

        If you publish work that uses or refers to PyGRANSO, please cite both
        PyGRANSO and GRANSO paper:

        [1] Buyun Liang, Tim Mitchell, and Ju Sun,
            NCVX: A User-Friendly and Scalable Package for Nonconvex
            Optimization in Machine Learning, arXiv preprint arXiv:2111.13984 (2021).
            Available at https://arxiv.org/abs/2111.13984

        [2] Frank E. Curtis, Tim Mitchell, and Michael L. Overton,
            A BFGS-SQP method for nonsmooth, nonconvex, constrained
            optimization and its evaluation using relative minimization
            profiles, Optimization Methods and Software, 32(1):148-181, 2017.
            Available at https://dx.doi.org/10.1080/10556788.2016.1208749

        solveQP.py (introduced in PyGRANSO v1.0.0)
        Copyright (C) 2016-2021 Tim Mitchell and Buyun Liang

        This file is a MATLAB-to-Python port of solveQP.m from
        GRANSO v1.6.4 with the following new functionality and/or changes:
            1. Replace MATLAB quadprog solver with OSQP https://osqp.org/
        Ported from MATLAB to Python and modified by Buyun Liang, 2021

        For comments/bug reports, please visit the PyGRANSO webpage:
        https://github.com/sun-umn/PyGRANSO

        =========================================================================
        |  PyGRANSO: A PyTorch-enabled port of GRANSO with auto-differentiation |
        |  Copyright (C) 2021 Tim Mitchell and Buyun Liang                      |
        |                                                                       |
        |  This file is part of PyGRANSO.                                       |
        |                                                                       |
        |  PyGRANSO is free software: you can redistribute it and/or modify     |
        |  it under the terms of the GNU Affero General Public License as       |
        |  published by the Free Software Foundation, either version 3 of       |
        |  the License, or (at your option) any later version.                  |
        |                                                                       |
        |  PyGRANSO is distributed in the hope that it will be useful,          |
        |  but WITHOUT ANY WARRANTY; without even the implied warranty of       |
        |  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        |
        |  GNU Affero General Public License for more details.                  |
        |                                                                       |
        |  You should have received a copy of the GNU Affero General Public     |
        |  License along with this program.  If not, see                        |
        |  <http://www.gnu.org/licenses/agpl.html>.                             |
        =========================================================================
    """
    global QP_REQUESTS
    QP_REQUESTS += 1

    try:
        if QPsolver == "osqp":
            # H,f always exist
            nvar = len(f)
            # H and A has to be sparse
            H = H.cpu().numpy()
            # avoid numerical issue in pygranso
            # epsilon = 1e-6
            # H = H + epsilon * np.eye(nvar)
            f = f.cpu().numpy()
            if A != None:
                A = A.cpu().numpy()
            # b = b.cpu().numpy()
            LB = LB.cpu().numpy()
            UB = UB.cpu().numpy()
            H_sparse = sparse.csc_matrix(H)
            # LB and UB always exist

            if np.any(A != None) and np.any(b != None):
                Aeq = A
                beq = b
                speye = sparse.eye(nvar)
                LB_new = np.vstack((beq,LB))
                UB_new = np.vstack((beq,UB))
                A_new = sparse.vstack([Aeq,speye])
                A_new = sparse.csc_matrix(A_new)
            else:
                #  no constraint A*x == b
                A_new = sparse.eye(nvar)
                A_new = sparse.csc_matrix(A_new)
                LB_new = LB
                UB_new = UB

            # Create an OSQP object
            prob = osqp.OSQP()

            # Setup workspace and change alpha parameter
            prob.setup(H_sparse, f, A_new, LB_new, UB_new, alpha=1.0,verbose=False)

            # Solve problem
            res = prob.solve()

            solution = res.x
            sol_len = solution.size
            solution = solution.reshape((sol_len,1))
            if double_precision:
                torch_dtype = torch.double
            else:
                torch_dtype = torch.float
            solution = torch.from_numpy(solution).to(device=torch_device, dtype=torch_dtype) 
            return solution

    except Exception as e:
        [w,v] = np.linalg.eigh(H)
        w_sorted = np.sort(w)
        print(w_sorted)
        print(traceback.format_exc())
        sys.exit()


def getErr():
    # getErr NOT used
    global QP_REQUESTS
    errors = 0
    return [QP_REQUESTS,errors]